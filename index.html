<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text-to-Audio Encryption</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; padding: 20px; position: relative; }
        textarea { width: 80%; height: 100px; margin-bottom: 10px; }
        button { padding: 10px; margin: 5px; cursor: pointer; }
        .version { position: absolute; top: 10px; right: 10px; font-size: 14px; color: gray; }
    </style>
</head>
<body>
    <div class="version">Version 2.43</div>
    <h1>Text-to-Audio Encryption</h1>
    <textarea id="textInput" placeholder="Enter text to encrypt"></textarea><br>
    <button onclick="encryptToAudio()">Encrypt & Play</button>
    <button onclick="decryptFromAudio()">Start Decoding</button>
    <h2>Decrypted Text:</h2>
    <p id="outputText"></p>
    <script>
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const sampleRate = 44100;
        const charDuration = 0.1;
        const noiseThreshold = 100;
        const baseFreq = 1000;
        const freqStep = 80;
        const startEndToneFreq = 400;
        const startEndToneDuration = 0.5;
        const pauseDuration = 0.3;

        const charMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ";
        const freqMap = {};
        charMap.split("").forEach((char, index) => {
            freqMap[char] = baseFreq + index * freqStep;
        });

        function encryptToAudio() {
            let text = document.getElementById("textInput").value.toUpperCase();
            let duration = (text.length * charDuration) + (2 * startEndToneDuration) + pauseDuration;
            let buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
            let channelData = buffer.getChannelData(0);

            function addTone(startSample, freq, length) {
                for (let i = 0; i < length * sampleRate; i++) {
                    channelData[startSample + i] = Math.sin(2 * Math.PI * freq * (i / sampleRate));
                }
            }

            let startSample = 0;
            addTone(startSample, startEndToneFreq, startEndToneDuration);
            startSample += (startEndToneDuration + pauseDuration) * sampleRate;

            for (let i = 0; i < text.length; i++) {
                let char = text[i];
                let freq = freqMap[char] || baseFreq;
                addTone(startSample, freq, charDuration);
                startSample += charDuration * sampleRate;
            }

            startSample += pauseDuration * sampleRate;
            addTone(startSample, startEndToneFreq, startEndToneDuration);

            let source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(audioContext.destination);
            source.start();
        }

        async function decryptFromAudio() {
            let stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            let analyser = audioContext.createAnalyser();
            let microphone = audioContext.createMediaStreamSource(stream);
            microphone.connect(analyser);
            analyser.fftSize = 4096;

            let buffer = new Float32Array(analyser.fftSize);
            let receivedText = "";
            let inTransmission = false;

            function goertzelFilter(frequency, samples) {
                let s1 = 0, s2 = 0;
                const coeff = 2 * Math.cos(2 * Math.PI * frequency / sampleRate);
                for (let sample of samples) {
                    let s0 = sample + coeff * s1 - s2;
                    s2 = s1;
                    s1 = s0;
                }
                return s1 * s1 + s2 * s2 - coeff * s1 * s2;
            }

            function processAudio() {
                analyser.getFloatTimeDomainData(buffer);
                let maxDetected = { char: null, power: 0 };

                for (let [char, freq] of Object.entries(freqMap)) {
                    let power = goertzelFilter(freq, buffer);
                    if (power > noiseThreshold && power > maxDetected.power) {
                        maxDetected = { char, power };
                    }
                }

                let startTonePower = goertzelFilter(startEndToneFreq, buffer);
                if (startTonePower > noiseThreshold) {
                    if (!inTransmission) {
                        inTransmission = true;
                        receivedText = "";
                    } else {
                        inTransmission = false;
                        document.getElementById("outputText").innerText = receivedText;
                    }
                }

                if (inTransmission && maxDetected.char) {
                    receivedText += maxDetected.char;
                }
            }

            setInterval(processAudio, charDuration * 1000);
        }
    </script>
</body>
</html>
